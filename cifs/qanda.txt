blocks * blocksize = n bytes
n/1024*1024 n megabytes



1. What is the block size? 256

2. How many blocks does the volume have?  65535

3. How large is the volume, in megabytes? 16mb

4. How many bits should be in the bitvector? 65535

5. How large will the bitvector be in bytes? 8192

    How many blocks is that? 32

6. Assuming block 0 is the first block, what block numbers are occupied by the bitvector?
0-31

7.Which block on the volume contains the superblock? 32

8. Which block contains the root folder? 33

9. Which block contains the root index? 34

10. What does the bitvector look like after creating the filesystem? a list of everything that is in data so if the bitvector is empty it would contain all zeros and if it was full it would contain all 1s or if its not empty nor full it would contain 0100001111101001100001... etc 

Understanding the Code

1. What code writes the bitvector? 

block[j] = cifsContext->bitvector[i * CIFS_BLOCK_SIZE + j];

        cifsWriteBlock((const unsigned char *) block, i);
	}

	// create all other blocks
	memset(block, 0, CIFS_BLOCK_SIZE);
	cifsWriteBlock((const unsigned char *) block, CIFS_NUMBER_OF_BLOCKS - 1);

	fflush(cifsVolume);
	fclose(cifsVolume);

	printf("CREATED CIFS VOLUME\n%d bytes\n%d blocks\nBlock size %d bytes\n",
			CIFS_NUMBER_OF_BLOCKS * CIFS_BLOCK_SIZE,
			CIFS_NUMBER_OF_BLOCKS,
			CIFS_BLOCK_SIZE);

    How many blocks are written?
	32 blocks are written for the bit vector and 1 for superblock, root folder, and root index

2. What code writes the superblock?

cifsWriteBlock((const unsigned char *) cifsContext->superblock, CIFS_SUPERBLOCK_INDEX);

    and where? block 33

3. What other blocks are written?

 the two blocks written are root folder and root index
	// now, write the two blocks for the root folder and set the corresponding bits in the bitvector
   cifsWriteBlock((const unsigned char *) &rootFolderBlock, cifsContext->superblock->cifsRootNodeIndex);
	cifsSetBit(cifsContext->bitvector, cifsContext->superblock->cifsRootNodeIndex);

   cifsWriteBlock((const unsigned char *) &rootFolderIndexBlock, cifsContext->superblock->cifsRootNodeIndex + 1);
	cifsSetBit(cifsContext->bitvector, cifsContext->superblock->cifsRootNodeIndex + 1);

    What are they?
root folder and root index to hold data and to be able to navigate through them

CREATE A FILE

1. What two blocks need to be created? index block and file descriptor


2. Where are they going to go on the volume, and how do you know? going on 1 and 2 since they are created after the root folder is created


3. Does the bitvector need to be updated? yes

    If so, what changes? the bitvector will change from 0 to 1 since it will show 0-2 have something in data 


4. Does the root folder block need to be updated? yes

    If so, what changes? because the size of the folder changes


5. Does the root index need to be updated? yes

    If so, what changes? yes so that we can go through the index and write things to our blocks


6. Does the superblock need to be updated? yes

    If so, what changes? yes because it has the number of blocks size and reference of the block holding te root folder




